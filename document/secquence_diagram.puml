@startuml
skinparam style strictuml
skinparam sequenceArrowThickness 1
skinparam sequenceParticipant underline

actor Cliente as Client
participant "Flask/Blueprint\nPresupuestoResource" as Controller
participant "validate_with(ArticuloSchema)\n(Decorator)" as Validator
participant "ArticuloSchema\n(Marshmallow)" as Schema
participant "PresupuestoService" as Service
participant "DolarApiService" as Dolar
participant "PresupuestoRepository" as Repo
participant "ResponseBuilder" as Builder

== Request entra ==
Client -> Controller: POST /api/v1/presupuesto/calcular\nBody: { articulo JSON }

note over Controller
El endpoint tiene @validate_with(ArticuloSchema)
Así que antes de entrar en la lógica,
pasa por el decorador.
end note

Controller -> Validator: ejecutar wrapper()
Validator -> Schema: load(request.json)
Schema --> Validator: articulo_obj (Articulo validado)\n(o error 400 si inválido)

Validator --> Controller: continua ejecución normal\n(ya con datos validados)

== Lógica de negocio ==
Controller -> Service: calcular_presupuesto(articulo_obj)

Service -> Dolar: get_tipo_cambio()
Dolar --> Service: tipo_cambio

Service -> Service: calcula impuestos, aranceles,\ncosto_total en base al Articulo y tipo_cambio

Service -> Repo: save(presupuesto_obj)
Repo --> Service: presupuesto_persistido (con id)

Service --> Controller: resultado = dict(\n  total, impuestos, aranceles, ...\n)

== Construcción de respuesta ==
Controller -> Builder: new ResponseBuilder()
Controller -> Builder: add_message("Cálculo generado")
Controller -> Builder: add_status_code(200)
Controller -> Builder: add_path("/api/v1/presupuesto/calcular")
Controller -> Builder: add_data(resultado)
Builder --> Controller: build() -> ResponseMessage

Controller --> Client: JSON(ResponseMessage), HTTP 200

@enduml
